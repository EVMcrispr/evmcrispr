#!/usr/bin/env bun
/**
 * Code-generation script for EVMcrispr modules.
 *
 * Scans `src/commands/` and `src/helpers/` in the current working directory
 * and generates `src/_generated.ts` with typed, static import maps.
 *
 * Usage: bun codegen.ts [srcDir]
 *   srcDir defaults to ./src
 */
import { existsSync, readdirSync, readFileSync, writeFileSync } from "node:fs";
import { join } from "node:path";

const srcDir = process.argv[2] || "./src";
const commandsDir = join(srcDir, "commands");
const helpersDir = join(srcDir, "helpers");

function getNames(dir: string): string[] {
  if (!existsSync(dir)) return [];
  return readdirSync(dir)
    .filter((f) => f.endsWith(".ts") && !f.startsWith("_"))
    .map((f) => f.replace(/\.ts$/, ""))
    .sort();
}

interface ArgDefMeta {
  name: string;
  type: string;
  optional?: boolean;
  rest?: boolean;
  signatureArgIndex?: number;
}

interface HelperMeta {
  returnType: string | null;
  hasArgs: boolean;
  argDefs: ArgDefMeta[];
  description: string | null;
}

function extractArgDefs(content: string): ArgDefMeta[] {
  const argsMatch = content.match(/args:\s*\[([\s\S]*?)\],/);
  if (!argsMatch || !argsMatch[1].trim()) return [];

  const argsContent = argsMatch[1];
  const result: ArgDefMeta[] = [];
  const objRegex = /\{([^}]+)\}/g;
  let m: RegExpExecArray | null;
  while ((m = objRegex.exec(argsContent)) !== null) {
    const obj = m[1];
    const nameMatch = obj.match(/name:\s*["']([^"']+)["']/);
    const typeMatch = obj.match(/type:\s*["']([^"']+)["']/);
    if (!nameMatch || !typeMatch) continue;

    const arg: ArgDefMeta = { name: nameMatch[1], type: typeMatch[1] };
    if (/optional:\s*true/.test(obj)) arg.optional = true;
    if (/rest:\s*true/.test(obj)) arg.rest = true;
    const sigArgIdxMatch = obj.match(/signatureArgIndex:\s*(\d+)/);
    if (sigArgIdxMatch) arg.signatureArgIndex = parseInt(sigArgIdxMatch[1], 10);
    result.push(arg);
  }

  return result;
}

function extractHelperMeta(dir: string, name: string): HelperMeta {
  const filePath = join(dir, `${name}.ts`);
  if (!existsSync(filePath))
    return { returnType: null, hasArgs: false, argDefs: [], description: null };
  const content = readFileSync(filePath, "utf-8");
  const rtMatch = content.match(/returnType:\s*["']([^"']+)["']/);
  const descMatch = content.match(/description:\s*["']([^"']+)["']/);
  const argDefs = extractArgDefs(content);
  const hasArgs = argDefs.length > 0;
  return {
    returnType: rtMatch?.[1] ?? null,
    hasArgs,
    argDefs,
    description: descMatch?.[1] ?? null,
  };
}

function extractCommandDescription(dir: string, name: string): string | null {
  const filePath = join(dir, `${name}.ts`);
  if (!existsSync(filePath)) return null;
  const content = readFileSync(filePath, "utf-8");
  const descMatch = content.match(/description:\s*["']([^"']+)["']/);
  return descMatch?.[1] ?? null;
}

const commandNames = getNames(commandsDir);
const helperNames = getNames(helpersDir);

const lines: string[] = [
  "// WARNING: this file is auto-generated by codegen. Do not edit.",
];

const imports: string[] = [];
if (commandNames.length > 0) imports.push("CommandImportMap");
if (helperNames.length > 0) imports.push("HelperImportMap");

if (imports.length > 0) {
  lines.push(`import type { ${imports.join(", ")} } from "@evmcrispr/sdk";`);
}

lines.push("");

if (commandNames.length > 0) {
  lines.push("export const commands: CommandImportMap = {");
  for (const name of commandNames) {
    const desc = extractCommandDescription(commandsDir, name);
    const parts: string[] = [`load: () => import("./commands/${name}")`];
    if (desc) parts.push(`description: ${JSON.stringify(desc)}`);
    lines.push(`  ${JSON.stringify(name)}: { ${parts.join(", ")} },`);
  }
  lines.push("};");
} else {
  lines.push("export const commands = {};");
}

lines.push("");

if (helperNames.length > 0) {
  lines.push("export const helpers: HelperImportMap = {");
  for (const name of helperNames) {
    const meta = extractHelperMeta(helpersDir, name);
    const parts: string[] = [];
    if (meta.returnType)
      parts.push(`returnType: ${JSON.stringify(meta.returnType)}`);
    parts.push(`hasArgs: ${meta.hasArgs}`);
    if (meta.argDefs.length > 0) {
      const defsStr = meta.argDefs
        .map((a) => {
          const props: string[] = [
            `name: ${JSON.stringify(a.name)}`,
            `type: ${JSON.stringify(a.type)}`,
          ];
          if (a.optional) props.push("optional: true");
          if (a.rest) props.push("rest: true");
          if (a.signatureArgIndex != null)
            props.push(`signatureArgIndex: ${a.signatureArgIndex}`);
          return `{ ${props.join(", ")} }`;
        })
        .join(", ");
      parts.push(`argDefs: [${defsStr}]`);
    }
    if (meta.description)
      parts.push(`description: ${JSON.stringify(meta.description)}`);
    lines.push(
      `  ${JSON.stringify(name)}: { load: () => import("./helpers/${name}"), ${parts.join(", ")} },`,
    );
  }
  lines.push("};");
} else {
  lines.push("export const helpers = {};");
}

lines.push(""); // trailing newline

const outPath = join(srcDir, "_generated.ts");
const content = lines.join("\n");

// Only write if content actually changed to avoid unnecessary filesystem events
// that trigger turbo watch / bun build --watch cascades.
if (!existsSync(outPath) || readFileSync(outPath, "utf-8") !== content) {
  writeFileSync(outPath, content);
  console.log(`codegen: wrote ${outPath}`);
} else {
  console.log(`codegen: ${outPath} up to date`);
}

import { Module } from "../Module";
import type {
  CommandImportMap,
  Commands,
  HelperArgDefEntry,
  HelperFunctions,
  HelperImportMap,
  IModuleConstructor,
  ModuleContext,
} from "../types";
import type { ArgType, CustomArgTypes } from "./schema";

/**
 * Create a module class with the given name, commands, and helpers.
 */
function createModuleClass<M extends Module>(
  name: string,
  commands: Commands<M>,
  helpers: HelperFunctions<M>,
  helperReturnTypes: Record<string, ArgType>,
  helperHasArgs: Record<string, boolean>,
  helperArgDefs: Record<string, HelperArgDefEntry[]>,
  types: CustomArgTypes = {},
  constants: Record<string, string> = {},
): IModuleConstructor {
  return class extends Module {
    constructor(context: ModuleContext, alias?: string) {
      super(
        name,
        commands,
        helpers,
        helperReturnTypes,
        helperHasArgs,
        helperArgDefs,
        constants,
        types,
        context,
        alias,
      );
    }
  } as IModuleConstructor;
}

/**
 * All-in-one factory for modules.
 *
 * Accepts typed import maps (generated by codegen) and wraps each entry
 * into a lazy loader that resolves the default export.
 *
 * @example
 * ```ts
 * import { commands, helpers } from "./_generated";
 *
 * export class MyModule extends defineModule("mymod", commands, helpers) {}
 * ```
 */
export function defineModule(
  name: string,
  commandImports: CommandImportMap,
  helperImports?: HelperImportMap,
  types?: CustomArgTypes,
  constants?: Record<string, string>,
): IModuleConstructor {
  const commands: Commands = Object.fromEntries(
    Object.entries(commandImports).map(([k, load]) => [
      k,
      () => load().then((m) => m.default),
    ]),
  );

  const helpers: HelperFunctions = helperImports
    ? Object.fromEntries(
        Object.entries(helperImports).map(([k, entry]) => [
          k,
          () => entry.load().then((m) => m.default),
        ]),
      )
    : {};

  const helperReturnTypes: Record<string, ArgType> = {};
  const helperHasArgs: Record<string, boolean> = {};
  const helperArgDefsMap: Record<string, HelperArgDefEntry[]> = {};
  if (helperImports) {
    for (const [k, entry] of Object.entries(helperImports)) {
      if (entry.returnType) {
        helperReturnTypes[k] = entry.returnType;
      }
      if (entry.hasArgs !== undefined) {
        helperHasArgs[k] = entry.hasArgs;
      }
      if (entry.argDefs) {
        helperArgDefsMap[k] = entry.argDefs;
      }
    }
  }

  return createModuleClass(
    name,
    commands,
    helpers,
    helperReturnTypes,
    helperHasArgs,
    helperArgDefsMap,
    types ?? {},
    constants ?? {},
  );
}

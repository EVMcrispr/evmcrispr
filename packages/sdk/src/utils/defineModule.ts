import { Module } from "../Module";
import type {
  CommandImportMap,
  Commands,
  HelperFunctions,
  HelperImportMap,
  IModuleConstructor,
  ModuleContext,
} from "../types";

/**
 * Create a module class with the given name, commands, and helpers.
 */
function createModuleClass<M extends Module>(
  name: string,
  commands: Commands<M>,
  helpers: HelperFunctions<M>,
  constants: Record<string, string> = {},
): IModuleConstructor {
  return class extends Module {
    constructor(context: ModuleContext, alias?: string) {
      super(name, commands, helpers, constants, context, alias);
    }
  } as IModuleConstructor;
}

/**
 * All-in-one factory for modules.
 *
 * Accepts typed import maps (generated by codegen) and wraps each entry
 * into a lazy loader that resolves the default export.
 *
 * @example
 * ```ts
 * import { commands, helpers } from "./_generated";
 *
 * export class MyModule extends defineModule("mymod", commands, helpers) {}
 * ```
 */
export function defineModule(
  name: string,
  commandImports: CommandImportMap,
  helperImports?: HelperImportMap,
  constants?: Record<string, string>,
): IModuleConstructor {
  const commands: Commands = Object.fromEntries(
    Object.entries(commandImports).map(([k, load]) => [
      k,
      () => load().then((m) => m.default),
    ]),
  );

  const helpers: HelperFunctions = helperImports
    ? Object.fromEntries(
        Object.entries(helperImports).map(([k, load]) => [
          k,
          () => load().then((m) => m.default),
        ]),
      )
    : {};

  return createModuleClass(name, commands, helpers, constants ?? {});
}
